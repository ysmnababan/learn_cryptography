
---
## Prerequisites

## 🏗️ Step 1: Start Postgres and Vault in Docker
Run the container for Postgres and Vault
```sh
docker compose up -d
```

👉 Now you have:
* Postgres on `localhost:5432` (admin user: `vault_admin`, password: `vault_admin_pass`)
* Vault on `localhost:8200` (root token: `root`)

---

## 🏗️ Step 2: Configure Vault (with local CLI)

1. Export Vault address and token:

   ```sh
   export VAULT_ADDR=http://127.0.0.1:8200
   export VAULT_TOKEN=root
   ```

2. Enable the database secrets engine:

   ```sh
   vault secrets enable database
   ```

3. Configure Vault to connect to Postgres using the admin account:

   ```sh
   vault write database/config/my-postgres ^
       plugin_name=postgresql-database-plugin ^
       allowed_roles="app-role,dev-role" ^
       connection_url="postgresql://{{username}}:{{password}}@host.docker.internal:5432/mydb?sslmode=disable" ^
       username="vault_admin" ^
       password="vault_admin_pass"
   ```

   🔎 `host.docker.internal` is important:

   * From Vault (running in Docker) → it needs to connect to Postgres (also in Docker).
   * Docker provides `host.docker.internal` to let one container access another via the host network.

4. Create a role for applications (short-lived creds):

   ```sh
   vault write database/roles/app-role \
       db_name=my-postgres \
       creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT CONNECT ON DATABASE mydb TO \"{{name}}\";" \
       default_ttl="1h" \
       max_ttl="24h"
   ```

   (You can also add `GRANT SELECT, INSERT ON ALL TABLES IN SCHEMA public TO "{{name}}";` if you want app-level access.)
   Please note that you have to place the [SQL file](/notes/key_rotation_pattern/demo/dynamicsecrets/dynamic_role.sql) at the
   same directory as you run this command
   ```sh
   vault write database/roles/app-role ^
    db_name=my-postgres ^
    creation_statements=@dynamic_role.sql ^
    default_ttl=1h ^
    max_ttl=24h
   ```

   
5. Test getting a dynamic credential:

   ```sh
   vault read database/creds/app-role
   ```

   You’ll see something like:

   ```txt
   Key                Value
   ---                -----
   lease_id           database/creds/app-role/8sdf98sdf...
   lease_duration     1h
   username           v-root-app-role-ZoP123456
   password           A1b2C3d4e5f6g7h8
   ```

   ✅ This is a real, temporary Postgres user created dynamically!

---

## 🏗️ Step 3: Test with Go app

Make a simple Go app [main.go](./main.go):
Run it:

```sh
go run main.go # don't forget to set up the ENV for TOKEN
```

You should see:

```
Got dynamic creds: v-root-app-role-XYZ / secret-pass
[some data]
```

🎉 Your Go app just connected with a **dynamic user** that will vanish after 1h.

---

## 🧩 How This Maps to Your Real Setup (Best Practice)

* In **practice**, you won’t run Postgres in Docker — you’ll point Vault’s `connection_url` at your existing DB host.
* Your **apps** (not humans) should use Vault to fetch short-lived creds.
* For accessing database, it is generally better for the creating several role for accessing it.
  * Superadmin/VaultAdmin: has the superuser priviledge. This user's credential is used by vault to connect to the DB for the first
    time. Admin must set the database for the right privilage so the app can access the tabl
  * Scheme Owner: has the priviledge to modify the scheme like creating, updating or even deleting table. Vault admin must set
    the privilege for this specific use too.
  * Developers: has the CRUD privilege. This is important so the developer can't directly edit the scheme. This is why `Vault` is 
    important so the developers doesn't have the access of root password
* Admin vault must create 2 kinds of role, for the app and for the developer. The app need to access the DB by using the `roleID`
  generated by the admin. This credential is sent securely (via env). App use this credential to get the token, and the token is
  used to get the credential needed for accessing various secret key. The developer also need specific role. This is important 
  so they can get temporary credential for accessing the DB so they can see it right on the DB for debugging purpose. Developer
  can authenticate/login to the `Vault` that has privilege and policy set by the admin, then this username and password (dynamically
  created) can be used to access the database.
---


